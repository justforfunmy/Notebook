<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        .box{
            height:100px;
            border-bottom: 1px solid #111;
        }
    </style>
</head>
<body>
    <div id='app'>
        <div class='box'>防抖展示1</div>
        <div class='box'>防抖展示2</div>
        <div class='box'>防抖展示3</div>
        <div class='box'>防抖展示4</div>
        <div class='box'>防抖展示5</div>
        <div class='box'>防抖展示6</div>
        <div class='box'>防抖展示7</div>
        <div class='box'>防抖展示8</div>
        <div class='box'>防抖展示9</div>
        <div class='box'>防抖展示10</div>
        <div class='box'>防抖展示11</div>
        <div class='box'>防抖展示12</div>
        <div class='box'>防抖展示13</div>
        <div class='box'>防抖展示1</div>
        <div class='box'>防抖展示2</div>
        <div class='box'>防抖展示3</div>
        <div class='box'>防抖展示4</div>
        <div class='box'>防抖展示5</div>
        <div class='box'>防抖展示6</div>
        <div class='box'>防抖展示7</div>
        <div class='box'>防抖展示8</div>
        <div class='box'>防抖展示9</div>
        <div class='box'>防抖展示10</div>
        <div class='box'>防抖展示11</div>
        <div class='box'>防抖展示12</div>
        <div class='box'>防抖展示13</div>
    </div>
</body>
<script>
    /* 在实际开发中，有些事件会持续触发，如scroll，resize事件，如果不停地执行处理函数，则会大大地消耗浏览器性能。这时就需要防抖函数来减少执行函数的频率。
    所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。
    防抖函数的原理是：设定一个延时器，在n秒内多次触发事件并不执行函数，而是在每次触发后都重置延时器，将函数延后执行，只有当n秒内不再触发事件，函数才会执行。以scroll事件为例，当我们滚动页面时，会
    不停地触发scroll事件，但每次触发事件，并不执行函数，而是重置延时器，只有当1秒内不触发事件才会执行函数*/
    function debounce(fn,timeout){
        //存储延时器
        let timer
        return function (){
            
            if(timer!==null){
                //防抖函数的代码使用这两行代码来获取 this 和 参数，是为了让 debounce 函数最终返回的函数 this 指向不变以及依旧能接受到 e 参数。
                let context = this
                let args = arguments
                //当再次触发事件时，如果有延时器存在，就清除当前延时器
                clearTimeout(timer)
                //重置延时器，即再延迟调用事件处理函数，只有当timeout时间内不再触发事件，才会执行函数
                timer = setTimeout(()=>{
                    //使得this不变
                    fn.apply(context,args)
                }, timeout);
            }
            
        }
    }
    function handle(){
        console.log(Math.random())
    }
    window.onscroll=debounce(handle,1000)
</script>
</html>